<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../../jacoco-resources/report.gif" type="image/gif"/><title>SendJobsRemindersUseCaseImpl.java</title><link rel="stylesheet" href="../../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../../index.html" class="el_report">MyJobsAggregateReport</a> &gt; <a href="../index.html" class="el_bundle">myjobs-core</a> &gt; <a href="index.source.html" class="el_package">com.wilzwert.myjobs.core.application.usecase</a> &gt; <span class="el_source">SendJobsRemindersUseCaseImpl.java</span></div><h1>SendJobsRemindersUseCaseImpl.java</h1><pre class="source lang-java linenums">package com.wilzwert.myjobs.core.application.usecase;


import com.wilzwert.myjobs.core.domain.model.job.Job;
import com.wilzwert.myjobs.core.domain.model.job.ports.driven.JobDataManager;
import com.wilzwert.myjobs.core.domain.model.user.User;
import com.wilzwert.myjobs.core.domain.model.user.batch.UsersJobsRemindersBulkResult;
import com.wilzwert.myjobs.core.domain.model.user.ports.driven.JobReminderMessageProvider;
import com.wilzwert.myjobs.core.domain.model.user.ports.driven.UserDataManager;
import com.wilzwert.myjobs.core.domain.model.user.ports.driving.SendJobsRemindersUseCase;
import com.wilzwert.myjobs.core.domain.shared.bulk.BulkDataSaveResult;
import com.wilzwert.myjobs.core.domain.shared.collector.UsersJobsBatchCollector;
import com.wilzwert.myjobs.core.domain.shared.specification.DomainSpecification;

import java.time.Instant;
import java.util.*;
import java.util.stream.Collectors;
import java.util.stream.Stream;

/**
 * @author Wilhelm Zwertvaegher
 */

public class SendJobsRemindersUseCaseImpl implements SendJobsRemindersUseCase {

    private final JobDataManager jobDataManager;

    private final UserDataManager userDataManager;

    private final JobReminderMessageProvider jobReminderMessageProvider;


<span class="fc" id="L33">    public SendJobsRemindersUseCaseImpl(JobDataManager jobDataManager, UserDataManager userDataManager, JobReminderMessageProvider jobReminderMessageProvider) {</span>
<span class="fc" id="L34">        this.jobDataManager = jobDataManager;</span>
<span class="fc" id="L35">        this.userDataManager = userDataManager;</span>
<span class="fc" id="L36">        this.jobReminderMessageProvider = jobReminderMessageProvider;</span>
<span class="fc" id="L37">    }</span>

    /**
     * This is the main logic for sending jobs reminders to a users/jobs chunk :
     * - send a message by user through the JobReminderMessageProvider
     * - save the jobs with their new followUpReminderSentAt through the JobDataManager
     * - save the users with their new jobFollowUpReminderSentAt through the UserDataManager
     * A reference to this method is passed to the batch collector
     * This method could (should ?) be moved to a domain service, but for now it will do
     * @param usersToJobs map of user -&gt; jobs, the relevant users and jobs
     * @return the results for this chunk
     */
    private UsersJobsRemindersBulkResult doSend(Map&lt;User, Set&lt;Job&gt;&gt; usersToJobs) {
<span class="fc" id="L50">        List&lt;String&gt; errors = new ArrayList&lt;&gt;();</span>
<span class="fc" id="L51">        Set&lt;User&gt; usersToSave = new HashSet&lt;&gt;();</span>
<span class="fc" id="L52">        int totalJobs = 0;</span>
<span class="fc bfc" id="L53" title="All 2 branches covered.">        for(Map.Entry&lt;User, Set&lt;Job&gt;&gt; entry : usersToJobs.entrySet()) {</span>

            try {
<span class="fc" id="L56">                jobReminderMessageProvider.send(entry.getKey(), entry.getValue());</span>
<span class="fc" id="L57">                usersToSave.add(entry.getKey());</span>
                // we have to map the jobs Set because the saveFollowUpReminderSentAt method returns a copy of the Job
<span class="fc" id="L59">                Set&lt;Job&gt; jobsToSave = entry.getValue().stream().map(Job::saveFollowUpReminderSentAt).collect(Collectors.toSet());</span>
<span class="fc" id="L60">                jobDataManager.saveAll(jobsToSave);</span>
<span class="fc" id="L61">                totalJobs += jobsToSave.size();</span>
            }
<span class="nc" id="L63">            catch (Exception e) {</span>
<span class="nc" id="L64">                errors.add(&quot;An error occurred while sending reminders to &quot;+entry.getKey()+&quot;: &quot;+e.getMessage());</span>
<span class="fc" id="L65">            }</span>
<span class="fc" id="L66">        }</span>
        // we have to map the users set because saveJobFollowUpReminderSentAt returns a copy of the User
<span class="fc" id="L68">        usersToSave = usersToSave.stream().map(User::saveJobFollowUpReminderSentAt).collect(Collectors.toSet());</span>
<span class="fc" id="L69">        BulkDataSaveResult serviceResult = null;</span>
<span class="pc bpc" id="L70" title="1 of 2 branches missed.">        if(!usersToSave.isEmpty()) {</span>
<span class="fc" id="L71">             serviceResult = userDataManager.saveAll(usersToSave);</span>
        }
<span class="pc bpc" id="L73" title="1 of 2 branches missed.">        int saveErrors = serviceResult != null ? serviceResult.totalCount()-serviceResult.updatedCount() : usersToSave.size();</span>
<span class="fc" id="L74">        return new UsersJobsRemindersBulkResult(usersToJobs.size(), totalJobs, errors, errors.size(), saveErrors);</span>
    }

    /**
     *  The entrypoint to this use case
     *  This method loads all the jobs that need reminders in a Stream, hen uses a custom collector which will iterate through
     *  the stream, chunk it and load the users through the provided callback (userDataManager.findMinimal...)
     *  and finally use a reference to this::doSend to actually send the reminders and collect and return the results
     * @param batchSize the chunk size passed by the infra ; as the infra knows what size can be handled
     * @return a list of results the infra may or may not use
     */
    @Override
    public List&lt;UsersJobsRemindersBulkResult&gt; sendJobsReminders(int batchSize) {
        // load jobs to remind...important : as UsersJobsBatchCollector expects Jobs to be pre-sorted by userId
        // the sort is configured in the DomainSpecification.JobFollowUpToRemind spec
<span class="fc" id="L89">        Stream&lt;Job&gt; jobsToRemind = jobDataManager.stream(DomainSpecification.JobFollowUpToRemind(Instant.now()));</span>
<span class="fc" id="L90">        return jobsToRemind.collect(</span>
                new UsersJobsBatchCollector&lt;&gt;(
<span class="fc" id="L92">                        userIds -&gt; userDataManager.findMinimal(DomainSpecification.in(&quot;id&quot;, userIds)),</span>
                        this::doSend,
                        batchSize
                )
        );
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.12.202403310830</span></div></body></html>